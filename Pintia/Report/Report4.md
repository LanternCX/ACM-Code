**题目**： 炮兵轰炸

**PTA判题得分**：50

### 一、问题描述

炮兵接到命令对指定区域进行炮击。假设敌方士兵分布在一个M×N格的二维平面上，每名士兵占据一格。向该平面的任意位置发射炮弹，炮弹的杀伤范围如下示意：

```
 O
OXO
 O
```

其中，X为炮弹落点中心，O为紧靠中心的四个有杀伤力的格子范围。若士兵被炮弹命中（位于X格），一击毙命，若仅被杀伤（位于O格），则损失一半的生命力。也就是说，一次命中或者两次杀伤均可消灭敌方士兵。现在给出士兵的分布情况以及连续k发炮弹的落点，给出每炮消灭的士兵数。最后给出被消灭的士兵总数、受伤的士兵总数。

**输入格式:**

输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。第一行为两个不超过20的正整数M和N，中间空一格，表示二维平面有M行、N列。

接下来M行，每行有N个0或者#字符，其中#表示所在格子有士兵。

接下来一行，包含一个不超过100的正整数k，表示发射炮弹的数量。

最后k行，每行包括一发炮弹的整数坐标x和y（0≤x<M，0≤y<N），之间用一个空格间隔。

**输出格式:**

对应输入的k发炮弹，输出k行，第i行即第i发炮弹消灭的士兵数。
然后另起一行输出总的消灭士兵数、受伤士兵数。两者用空格隔开。

**输入样例:**

```in
5 5
00###
0##00
00#00
##000
#0#0#
3
0 2
1 1
1 2
```

**输出样例:**

```out
1
2
0
3 2
```

- ### 二、数据结构定义与分析

  本次实验中定义了以下3个变量（包含1个二维数组和2个整型数组）：

  - `map` 用于存储地图上每个格子的状态，初始化为输入的地图数据，其中 `0` 表示没有士兵，`2` 表示士兵满血，`1` 表示士兵受伤但未被消灭；（二维整型数组）
  - `cross` 用于存储炮弹的伤害范围，其中 `2` 表示中心位置的致命伤害，`1` 表示周围位置的轻伤；（二维整型数组）
  - `ans` 用于统计最终的实验结果，`ans[0]` 表示被消灭士兵的总数，`ans[1]` 表示受伤士兵的总数；（整型数组）
  - `m, n` 表示二维平面有M行、N列；（整型变量）
  - `s`表示输入的每行地图；（字符串）
  - `k`表示发射炮弹的数量；（整型变量）
  - `x, y` 表示一发炮弹的整数坐标x和y；（整型变量）
  - `res` 表示每次炮弹消灭的士兵；（整型变量）
  - `i, j`用于控制循环进行数组的遍历等；（整型变量）

### 三、算法分析

本题是一个模拟题，需要根据题目模拟题目所述的算法。注意到炮弹有伤害一次消灭和伤害两次消灭两种情况，考虑将士兵抽象为一个血量值为`2`的格点，再根据题意模拟计算。再模拟中，可以利用`3*3`数组cross记录炮弹在范围内每一格的伤害值，以减少对炮弹击中区域的繁琐判断。

1. 先根据题意读取地图的大小 `M` 和 `N`，以及地图的初始状态；
2. 利用循环 `while(k--)` 逐个读取每次炮弹的坐标，并判断是否还有未处理的炮弹；
3. 在每次循环中：
   - 根据当前炮弹的落点坐标，计算其杀伤范围内的伤害；
   - 遍历炮弹影响的区域，更新地图中对应位置士兵的生命值；
   - 判断士兵是否被击杀，统计每次炮弹消灭的士兵数，打印消灭数量`res`，并实时更新结果 `ans[0]`；
4. 在所有炮弹发射完成后，遍历地图，统计受伤但未被消灭的士兵数，更新结果 `ans[1]`；
5. 最终输出总的被消灭士兵数和受伤士兵数。

### 四、测试用例设计及测试结果

#### 1. 样例测试

**输入：**

```in
5 5
00###
0##00
00#00
##000
#0#0#
3
0 2
1 1
1 2
```

**预期输出：**

```
1
2
0
3 2
```

**实际输出：**



#### 2. 边界测试

**输入：**

```
20 20
#0000000000000000000
00##0000000000000000
0000##00000000000000
000000##000000000000
000000000##000000000
000000000000##000000
000000000000000##000
000000000000000000#0
0000000000000000000#
0000##00000000000000
000000##000000000000
000000000##000000000
000000000000##000000
000000000000000##000
000000000000000000#0
0000000000000000000#
#0000000000000000000
00##0000000000000000
0000##00000000000000
000000##000000000000
100
1 1
2 2
3 3
4 4
5 5
6 6
7 7
8 8
9 9
10 10
11 11
12 12
13 13
14 14
15 15
16 16
17 17
18 18
19 19
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
10 11
11 12
12 13
13 14
14 15
15 16
16 17
17 18
18 19
1 0
2 1
3 2
4 3
5 4
6 5
7 6
8 7
9 8
10 9
11 10
12 11
13 12
14 13
15 14
16 15
17 16
18 17
19 18
0 0
0 1
0 2
0 3
0 4
0 5
0 6
0 7
0 8
0 9
0 10
0 11
0 12
0 13
0 14
0 15
0 16
0 17
0 18
0 19
19 0
19 1
19 2
19 3
19 4
19 5
19 6
19 7
19 8
19 9
19 10
19 11
19 12
19 13
19 14
19 15
19 16
19 17
19 18
19 19
```

**预期输出：**

```
0
1
0
0
0
0
0
0
0
0
1
1
1
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
1
1
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
11 2
```

**实际输出：**



从以上测试当中可以检验出程序的完备性

### 五、存在问题及可能原因

1. **坐标变换错误**
   - **问题**：在算法实现当中设计到的多处坐标变换处理错误 
   - **原因**：可能是在坐标变换中对下标为0开头的数组和下标为1开头的数组变换不正确，为进行 +1 或 -1操作
4. **伤害计算错误**  
   - **问题**：炮弹的伤害没有被正确计算
   - **原因**：忽略了题目中要求的炮弹直接击中消灭士兵和在炮弹周围使士兵受伤的条件，模拟错误
3. **消灭士兵数量计算错误**
   - **问题**：受伤的士兵被第二次击中没有被正确消灭
   - **原因**：未记录士兵当前血量，导致士兵的状态没有被记录

### 六、附源代码以及代码相应注释

```c++
#include <stdio.h>
// 地图数组
int map[30][30];
// 炮弹轰炸范围与轰炸伤害
int cross[3][3] = {
    0, 1 ,0,
    1, 2, 1,
    0, 1, 0
};

int main(){
    // 题目给定的 m, n
    int m, n;
    scanf("%d %d", &m, &n);
    // 输入地图
    for(int i = 1; i <= m; i++){
        // 使用字符串按行输入
        char s[30];
        scanf("%s", s);
        for(int j = 1; j <= n; j++){
            char x = s[j - 1];
            // 将输入的字符 '0' 映射为数字 0，表示没有士兵
            if(x == '0'){
                map[i][j] = 0;
            }
            // 将输入的字符 '#' 映射为数字 2，表示士兵的血量为2
            if(x == '#'){
                map[i][j] = 2;
            }
        }
    }
    // 题目给定的k值
    int k;
    scanf("%d", &k);
    // 答案数组，ans[0] 表示第一个答案，ans[1] 表示第二个答案
    int ans[2] = {0, 0};
    // 循环 k 次读取炮弹坐标
    while(k--){
        // 题目给定的炮弹坐标 x, y
        int x, y;
        scanf("%d %d", &x, &y);
        // 将题目给定的炮弹坐标映射到下标为 1 开头的map数组上
        x += 1;
        y += 1;

        // res(result) 记录每次炮弹消灭的士兵
        int res = 0;
        // 遍历 cross 计算士兵受到的伤害
        for(int i = 0; i < 3; i++){
            for(int j = 0; j < 3; j++){
                // 本次循环计算伤害的坐标
                int x0 = x - 1 + i;
                int y0 = y - 1 + j;
                // 如果坐标在地图外就跳过本次循环进行下一次循环
                if(x0 <= 0|| y0 <= 0 || x > m || y > m){
                    continue;
                }

                // temp 用于保存伤害计算前的士兵血量
                int temp = map[x0][y0];
                // 计算伤害
                map[x0][y0] -= cross[i][j];
                // 判断是否消灭士兵，计算答案
                if(temp > 0 && map[x0][y0] <= 0){
                    res++;
                }
            }
        }
        // 打印答案
        printf("%d\n", res);
        // 计算总消灭士兵数量
        ans[0] += res;
    }

    // 计算受伤的士兵数量
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            if(map[i][j] == 1){
                ans[1]++;
            }
        }
    }
    // 打印答案
    printf("%d %d", ans[0], ans[1]);
    return 0;
}
```

### 七、实验总结及建议

本次实验相比一般的题目程序复杂度较高，是一道较为复杂的模拟题。在实现模拟题的题干中的算法时，需要先对题目进行充分的理解以及构建清晰的思路，再对算法进行实现。模拟题的算法一般来说较为复杂，不能在读完题后直接开始进行代码的书写，需要先确定思路，否则会造成代码逻辑混乱，且对调试造成不必要的困难。实际上，模拟题的难度并不算大，考验的是选手的细心与耐心。在实现模拟题的时候，一定不能急躁，需要耐心阅读题干并实现所需的算法。
