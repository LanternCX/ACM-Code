**题目**：足球比赛积分排名

**PTA判题得分**：50

### 一、问题描述

本赛季足球联赛结束了。请根据比赛结果，给队伍排名。排名规则：

（1）先看积分，积分高的名次在前（每场比赛胜者得3分，负者得0分，平局各得1分）；

（2）若积分相同，则看净胜球（该队伍的进球总数与失球总数之差），净胜球多的排名在前；

（3）若积分和净胜球都相同，则看总进球数，进球总数多的排名在前；

（4）若积分、净胜球和总进球数都相同，则队伍编号小的排名在前。

**输入格式:**

先输入一个正整数n（n<1000），代表参赛队伍总数。方便起见，队伍以编号1，2，……，n表示。然后输入n * (n-1)/2行比赛数据，依次代表包含这n个队伍之间进行单循环比赛的结果，具体格式为：i j p q, 其中i、j分别代表两支队伍的编号（1≤i<j≤n），p、q代表队伍i和队伍j的各自进球数（0≤p，q≤50）。

**输出格式:**

按比赛排名规则，从高到低依次输出队伍的编号，每个队伍之后留一个空格。

**输入样例:**

```in
4
1 2 0 2
1 3 1 1
1 4 0 0
2 3 2 0
2 4 4 0
3 4 2 2
```

**输出样例:**

表示2号队伍排名最高。

```out
2 3 1 4 
```

### 二、数据结构定义与分析

本次实验中定义了以下一个结构体：

- `Team`:
  - `sc`：球队积分
  - `det_goal`：净胜球
  - `goal`：总进球
  - `id`：球队编号

本次实验中定义了以下二个函数：

- `void swap(struct Team *a, struct Team *b)`：交换两个球队信息，函数输入 2 个结构指针变量，定义了 1 个结构变量：
  - `*a`：指向需要交换的第一个球队的指针；(结构`Team`型指针变量)
  - `*b`：指向需要交换的第二个球队的指针；(结构`Team`型指针变量)
  - `temp`：用于暂存 `*a`的值进行交换；(结构`Team`型变量)
- `void sort(struct Team * begin, struct Team * end)`：对球队按题目给定的规则进行冒泡，函数输入2个结构指针变量，定义了 2 个整型变量，1 个结构指针变量：
  - `*begin`：指向球队数组第一个元素的指针；(结构`Team`型指针变量)
  - `*end`：指向数组最后一个元素的后一个元素的指针；(结构`Team`型指针变量)
  - `is_sorted`：用于判断数组是否已按照规则排序；（整型变量）
  - `is_swap`：用于判断是否需要交换，即用于判断两个结构是否不满足排序条件；（整型变量）
  - `*i`：用于控制循环进行数组的遍历；(结构`Team`型指针变量)

本次实验主函数以及全局中定义了以下几个变量（包含 1 个一维结构数组， 6 个整形变量）：

- `n` 球队总数；
- `a, b` 输入的第一个球队 A 和第二个球队 B 的编号；（整型变量）
- `p, q` 输入的球队 A 的进球数与球队 B 的进球数；（整型变量）
- `i`用于控制循环进行数据的输入与答案的打印等；（整型变量）
- `list`：球队列表；（一维结构`Team`数组）

### 三、算法分析

本题是一个排序题，通过观察题面和数据范围可知，使用复杂度为`O(n^2)`的排序算法，根据题意对一个自定结构体进行排序即可通过此题。对于此题，较为考察的是编程者对于排序算法过程的理解，以及对题目题意的阅读理解能力，以及对面向结构体编程的熟练度，以及模拟功底。

根据题意输入后，对于每一场输入的比赛，根据题意和输入的数据计算出球队在当前场比赛结束过后的球队积分、净胜球、总进球、球队编号。

在完成输入后，对存储球队数据的数组`list`使用自定义函数`void sort(struct Team * begin, struct Team * end)`进行排序。

前面提到，使用复杂度为`O(n^2)`的排序算法可通过此题，而较为经典的复杂度为`O(n^2)`的排序算法有选择排序、插入排序、冒泡排序等，在这里选择冒泡排序进行排序。

一般来说冒泡排序的模板只比较两个变量的值以判断是否将当前变量向前冒泡，而对于结构体而言，结构体的多个变量则需要根据题意进行比较来判断是否向前冒泡。

对于自定义函数`sort()`和`swap()`，可以仿照经典的`c++ STL`库中的排序 API  `sort()` 和交换 API `swap()`的程序设计范式进行设计，即结合指针和数组进行设计。

### 四、测试用例设计及测试结果

#### 1. 样例测试

**输入：**

```in
4
1 2 0 2
1 3 1 1
1 4 0 0
2 3 2 0
2 4 4 0
3 4 2 2
```

**预期输出：**

```
2 3 1 4 
```

**实际输出：**

#### 2. 最简单情况

**输入：**

```
2
1 2 3 1
```

**预期输出：**

```
1 2
```

**实际输出：**



#### 3. 编号决定排名

**输入：**

```
4
1 2 1 1
1 3 1 1
1 4 1 1
2 3 1 1
2 4 1 1
3 4 1 1
```

**预期输出：**

```
1 2 3 4
```

**实际输出：**



#### 4. 净胜球决定排名

**输入：**

```
3
1 2 1 1
1 3 2 1
2 3 3 1
```

**预期输出：**

```
2 1 3
```

**实际输出：**



#### 3. 总进球决定排名

总进球决定排名

**输入：**

```
4
1 2 1 1
1 3 2 2
1 4 3 3
2 3 1 0
2 4 1 0
3 4 1 0
```

**预期输出：**

```
2 3 1 4
```

**实际输出：**



从以上测试当中可以检验出程序的完备性

### 五、存在问题及可能原因

1. **数值计算错误**
   - **问题**：在算法实现当中存在球队积分净胜球等计算的错误
   - **原因**：可能是题意理解不清或者编程不够仔细导致
2. **冒泡排序没有正常执行**
   - **问题**：冒泡排序的冒泡条件没有正确判断
   - **原因**：可能是忽略了题目中给定的条件的某一项或者用于判断升序降序的不等号书写错误
3. **交换函数没有正常执行**
   - **问题**：使用`swap()`时两个元素没有正常交换
   - **原因**：可能是指针运算错误导致

### 六、附源代码以及代码相应注释

```c++
#include <stdio.h>
/**
 * 球队结构体
 */
struct Team{
    /**
     * 球队积分
     */
    int sc;
    /**
     * 净胜球
     */
    int det_goal;
    /**
     * 总进球
     */
    int goal;
    /**
     * 球队编号
     */
    int id;
};
/**
 * @brief 交换两个球队信息
 * @param a 指向球队A的指针
 * @param b 指向球队B的指针
 */
void swap(struct Team *a, struct Team *b){
    struct Team temp = *a;
    *a = *b;
    *b = temp;
}
/**
 * @brief 对球队按题目给定的规则进行冒泡
 * @param begin 指向数组第一个元素的指针
 * @param end 指向数组最后一个元素的后一个元素的指针
 */
void sort(struct Team * begin, struct Team * end){
    // 是否已排序，作为冒泡排序终止的判断条件
    int is_sorted = 1;
    // 冒泡排序
    while(is_sorted){
        // 初始化终止条件为伪值
        is_sorted = 0;
        // 遍历第 1 个到第 n - 1 个球队
        for(struct Team *i = begin; i < end - 1; i++){
            // 是否交换两个元素
            int is_swap = 0;
            // 比较积分，积分较大的向前冒泡
            if(i->sc < (i + 1)->sc){
                is_swap = 1;
            }else if(i->sc == (i + 1)->sc){
                // 积分相等，比较净胜球，净胜球较大的向前冒泡
                if(i->det_goal < (i + 1)->det_goal){
                    is_swap = 1;
                }else if(i->det_goal == (i + 1)->det_goal) {
                    // 净胜球相等，比较总进球，总进球较大的向前冒泡
                    if(i->goal < (i + 1)->goal){
                        is_swap = 1;
                    }else if(i->goal == (i + 1)->goal){
                        // 总进球相等，比较球队编号，球队编号较小的向前冒泡
                        if(i->id > (i + 1)->id){
                            is_swap = 1;
                        }
                    }
                }
            }
            // 判断是否进行交换，即是否将第 i + 1 个元素向前冒泡
            if(is_swap){
                // 执行过冒泡说明序列未完成排序，进行下一次遍历
                is_sorted = 1;
                // 执行交换
                swap(i, i + 1);
            }
        }
    }
}
int main(){
    // 球队列表
    struct Team list[1000];
    // 球队总数 n
    int n;
    // 输入球队总数 n
    scanf("%d", &n);
    // 输入比赛数据
    for(int i = 0; i < n * (n - 1) / 2; i++){
        // 比赛数据：球队A编号，球队B编号，球队A得分，球队B得分
        int a, b, p, q;
        scanf("%d %d %d %d", &a, &b, &p, &q);
        // 记录球队A编号，0 开头数组下标应 -1
        list[a - 1].id = a;
        // 计算球队A总进球
        list[a - 1].goal += p;
        // 计算球队A净胜球
        list[a - 1].det_goal += p - q;
        // 计算球队A的积分
        if(p == q){
            // 如果平局球队A加一分
            list[a - 1].sc += 1;
        }else if(p > q){
            // 如果球队A获胜球队A加一分
            list[a - 1].sc += 3;
        }
        // 如果球队A战败则不加分
        
        // 记录球队B编号，0 开头数组下标应 -1
        list[b - 1].id = b;
        // 计算球队B总进球
        list[b - 1].goal += q;
        // 计算球队B净胜球
        list[b - 1].det_goal += q - p;
        // 计算球队B的积分
        if(p == q){
            // 如果平局球队B加一分
            list[b - 1].sc += 1;
        }else if(p < q){
            // 如果球队B获胜球队B加一分
            list[b - 1].sc += 3;
        }
    }
    // 对所有球队进行排序，区间左右闭
    sort(list, list + n);
    // 遍历排序后的球队列表，打印球队编号
    for(int i = 0; i < n; i++){
        printf("%d ", list[i].id);
    }
    // 主函数默认约定返回值为 0
    return 0;
}
```

### 七、实验总结及建议

本次实验相比一般的题目程序复杂度较高，是一道较为复杂的排序。排序算法的种类较多， 根据题目数据范围使用合适的排序算法是第一步。而对于题目中这种较为复杂的结构体排序，则需要对题目进行充分的阅读理解解构题意再进行排序算法的实现。与模拟题类似，排序题更多的是考验编程者对于题目的理解和扎实的模拟功底，而非对于排序算法本身模板的理解。在实现排序题时，务必保持程序的结构清晰，实现思路清晰，对题意的理解清晰，以免造成算法实现过程中的不必要的错误导致调试困难。